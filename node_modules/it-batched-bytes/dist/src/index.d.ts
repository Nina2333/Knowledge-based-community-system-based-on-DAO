import { Uint8ArrayList } from 'uint8arraylist';
import type { Source } from 'it-stream-types';
export interface BatchedBytesOptions {
    /**
     * The minimum number of bytes that should be in a batch (default: 1MB)
     */
    size?: number;
    /**
     * If this amount of time passes, yield all the bytes in the batch even
     * if they are below `size` (default: 0 - e.g. on every tick)
     */
    yieldAfter?: number;
}
export interface BatchedOptions<T> {
    /**
     * The minimum number of bytes that should be in a batch (default: 1MB)
     */
    size?: number;
    /**
     * If this amount of time passes, yield all the bytes in the batch even
     * if they are below `size` (default: 0 - e.g. on every tick)
     */
    yieldAfter?: number;
    /**
     * If passed, this function should serialize the object and append the
     * result to the passed list
     */
    serialize: (object: T, list: Uint8ArrayList) => void;
}
/**
 * Takes a stream of Uint8Arrays and/or Uint8ArrayLists and store them in
 * an internal buffer. Either once the buffer reaches the requested size
 * or the next event loop tick occurs, yield any bytes from the buffer.
 */
declare function batchedBytes(source: Source<Uint8Array | Uint8ArrayList>, options?: BatchedBytesOptions): Source<Uint8Array>;
declare function batchedBytes<T>(source: Source<T>, options: BatchedOptions<T>): Source<Uint8Array>;
export default batchedBytes;
//# sourceMappingURL=index.d.ts.map