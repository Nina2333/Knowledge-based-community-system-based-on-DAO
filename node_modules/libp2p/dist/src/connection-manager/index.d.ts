import { SummaryObject } from './latency-monitor.js';
import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import type { Startable } from '@libp2p/interfaces/startable';
import { PeerId } from '@libp2p/interface-peer-id';
import type { Connection, MultiaddrConnection } from '@libp2p/interface-connection';
import type { ConnectionManager, ConnectionManagerEvents, Dialer } from '@libp2p/interface-connection-manager';
import type { AddressSorter, PeerStore } from '@libp2p/interface-peer-store';
import { Multiaddr, Resolver } from '@multiformats/multiaddr';
import type { Metrics } from '@libp2p/interface-metrics';
import type { Upgrader } from '@libp2p/interface-transport';
export interface ConnectionManagerConfig {
    /**
     * The maximum number of connections libp2p is willing to have before it starts disconnecting. Defaults to `Infinity`
     */
    maxConnections: number;
    /**
     * The minimum number of connections below which libp2p not activate preemptive disconnections. Defaults to `0`.
     */
    minConnections: number;
    /**
     * Sets the maximum event loop delay (measured in milliseconds) this node is willing to endure before it starts disconnecting peers. Defaults to `Infinity`.
     */
    maxEventLoopDelay?: number;
    /**
     * Sets the poll interval (in milliseconds) for assessing the current state and determining if this peer needs to force a disconnect. Defaults to `2000` (2 seconds).
     */
    pollInterval?: number;
    /**
     * If true, try to connect to all discovered peers up to the connection manager limit
     */
    autoDial?: boolean;
    /**
     * How long to wait between attempting to keep our number of concurrent connections
     * above minConnections
     */
    autoDialInterval: number;
    /**
     * Sort the known addresses of a peer before trying to dial
     */
    addressSorter?: AddressSorter;
    /**
     * Number of max concurrent dials
     */
    maxParallelDials?: number;
    /**
     * Number of max addresses to dial for a given peer
     */
    maxAddrsToDial?: number;
    /**
     * How long a dial attempt is allowed to take, including DNS resolution
     * of the multiaddr, opening a socket and upgrading it to a Connection.
     */
    dialTimeout?: number;
    /**
     * When a new inbound connection is opened, the upgrade process (e.g. protect,
     * encrypt, multiplex etc) must complete within this number of ms.
     */
    inboundUpgradeTimeout: number;
    /**
     * Number of max concurrent dials per peer
     */
    maxDialsPerPeer?: number;
    /**
     * Multiaddr resolvers to use when dialing
     */
    resolvers?: Record<string, Resolver>;
    /**
     * On startup we try to dial any peer that has previously been
     * tagged with KEEP_ALIVE up to this timeout in ms. (default: 60000)
     */
    startupReconnectTimeout?: number;
    /**
     * A list of multiaddrs that will always be allowed (except if they are in the
     * deny list) to open connections to this node even if we've reached maxConnections
     */
    allow?: string[];
    /**
     * A list of multiaddrs that will never be allowed to open connections to
     * this node under any circumstances
     */
    deny?: string[];
    /**
     * If more than this many connections are opened per second by a single
     * host, reject subsequent connections
     */
    inboundConnectionThreshold?: number;
    /**
     * The maximum number of parallel incoming connections allowed that have yet to
     * complete the connection upgrade - e.g. choosing connection encryption, muxer, etc
     */
    maxIncomingPendingConnections?: number;
}
export interface DefaultConnectionManagerComponents {
    peerId: PeerId;
    metrics?: Metrics;
    upgrader: Upgrader;
    peerStore: PeerStore;
    dialer: Dialer;
}
export type ConnectionManagerInit = ConnectionManagerConfig;
/**
 * Responsible for managing known connections.
 */
export declare class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable {
    private readonly components;
    private readonly opts;
    private readonly connections;
    private started;
    private readonly latencyMonitor?;
    private readonly startupReconnectTimeout;
    private connectOnStartupController?;
    private readonly dialTimeout;
    private readonly allow;
    private readonly deny;
    private readonly inboundConnectionRateLimiter;
    private incomingPendingConnections;
    constructor(components: DefaultConnectionManagerComponents, init: ConnectionManagerConfig);
    isStarted(): boolean;
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    start(): Promise<void>;
    afterStart(): Promise<void>;
    beforeStop(): Promise<void>;
    /**
     * Stops the Connection Manager
     */
    stop(): Promise<void>;
    /**
     * Cleans up the connections
     */
    _close(): Promise<void>;
    onConnect(evt: CustomEvent<Connection>): void;
    /**
     * Tracks the incoming connection and check the connection limit
     */
    _onConnect(evt: CustomEvent<Connection>): Promise<void>;
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt: CustomEvent<Connection>): void;
    getConnections(peerId?: PeerId): Connection[];
    openConnection(peerIdOrMultiaddr: PeerId | Multiaddr, options?: AbortOptions): Promise<Connection>;
    closeConnections(peerId: PeerId): Promise<void>;
    /**
     * Get all open connections with a peer
     */
    getAll(peerId: PeerId): Connection[];
    /**
     * If the event loop is slow, maybe close a connection
     */
    _onLatencyMeasure(evt: CustomEvent<SummaryObject>): void;
    /**
     * If the `value` of `name` has exceeded its limit, maybe close a connection
     */
    _checkMaxLimit(name: keyof ConnectionManagerInit, value: number, toPrune?: number): Promise<void>;
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    _pruneConnections(toPrune: number): Promise<void>;
    acceptIncomingConnection(maConn: MultiaddrConnection): Promise<boolean>;
    afterUpgradeInbound(): void;
}
//# sourceMappingURL=index.d.ts.map