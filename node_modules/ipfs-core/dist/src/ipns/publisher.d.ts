export class IpnsPublisher {
    /**
     * @param {import('ipfs-core-types/src/utils').BufferStore} routing
     * @param {import('interface-datastore').Datastore} datastore
     */
    constructor(routing: import('ipfs-core-types/src/utils').BufferStore, datastore: import('interface-datastore').Datastore);
    _routing: import("ipfs-core-types/src/utils").BufferStore;
    _datastore: import("interface-datastore").Datastore;
    /**
     * Publish record with a eol
     *
     * @param {PeerId} peerId
     * @param {Uint8Array} value
     * @param {number} lifetime
     * @param {AbortOptions} [options]
     */
    publishWithEOL(peerId: PeerId, value: Uint8Array, lifetime: number, options?: import("@libp2p/interfaces").AbortOptions | undefined): Promise<Uint8Array>;
    /**
     * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system
     *
     * @param {PeerId} peerId
     * @param {Uint8Array} value
     * @param {AbortOptions} options
     */
    publish(peerId: PeerId, value: Uint8Array, options: AbortOptions): Promise<Uint8Array>;
    /**
     * @param {Uint8Array} record
     * @param {PeerId} peerId
     * @param {AbortOptions} [options]
     */
    _putRecordToRouting(record: Uint8Array, peerId: PeerId, options?: import("@libp2p/interfaces").AbortOptions | undefined): Promise<Uint8Array>;
    /**
     * @param {Uint8Array} key
     * @param {Uint8Array} entry
     * @param {AbortOptions} [options]
     */
    _publishEntry(key: Uint8Array, entry: Uint8Array, options?: import("@libp2p/interfaces").AbortOptions | undefined): Promise<void>;
    /**
     * Returns the record this node has published corresponding to the given peer ID.
     *
     * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.
     *
     * @param {PeerId} peerId
     * @param {object} options
     * @param {boolean} [options.checkRouting]
     */
    _getPublished(peerId: PeerId, options?: {
        checkRouting?: boolean | undefined;
    }): Promise<ipns.IPNSEntry>;
    /**
     * @param {Uint8Array} data
     */
    _unmarshalData(data: Uint8Array): ipns.IPNSEntry;
    /**
     * @param {PeerId} peerId
     * @param {Uint8Array} value
     * @param {number} lifetime
     * @param {AbortOptions} [options]
     */
    _updateOrCreateRecord(peerId: PeerId, value: Uint8Array, lifetime: number, options?: import("@libp2p/interfaces").AbortOptions | undefined): Promise<Uint8Array>;
}
export namespace IpnsPublisher {
    export { defaultRecordLifetime };
}
export type PrivateKey = import('@libp2p/interface-keys').PrivateKey;
export type PublicKey = import('@libp2p/interface-keys').PublicKey;
export type IPNSEntry = import('ipns').IPNSEntry;
export type PeerId = import('@libp2p/interface-peer-id').PeerId;
export type AbortOptions = import('@libp2p/interfaces').AbortOptions;
import * as ipns from "ipns";
declare const defaultRecordLifetime: number;
export {};
//# sourceMappingURL=publisher.d.ts.map