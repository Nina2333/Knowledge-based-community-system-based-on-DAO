import { Gauge } from 'prom-client';
import { normaliseString } from './utils.js';
export class PrometheusMetricGroup {
    constructor(name, opts) {
        name = normaliseString(name);
        const help = normaliseString(opts.help ?? name);
        const label = this.label = normaliseString(opts.label ?? name);
        let collect;
        this.calculators = [];
        // calculated metric
        if (opts?.calculate != null) {
            this.calculators.push(opts.calculate);
            const self = this;
            collect = async function () {
                await Promise.all(self.calculators.map(async (calculate) => {
                    const values = await calculate();
                    Object.entries(values).forEach(([key, value]) => {
                        this.set({ [label]: key }, value);
                    });
                }));
            };
        }
        this.gauge = new Gauge({
            name,
            help,
            labelNames: [this.label],
            registers: opts.registry !== undefined ? [opts.registry] : undefined,
            collect
        });
    }
    addCalculator(calculator) {
        this.calculators.push(calculator);
    }
    update(values) {
        Object.entries(values).forEach(([key, value]) => {
            this.gauge.set({ [this.label]: key }, value);
        });
    }
    increment(values) {
        Object.entries(values).forEach(([key, value]) => {
            const inc = typeof value === 'number' ? value : 1;
            this.gauge.inc({ [this.label]: key }, inc);
        });
    }
    decrement(values) {
        Object.entries(values).forEach(([key, value]) => {
            const dec = typeof value === 'number' ? value : 1;
            this.gauge.dec({ [this.label]: key }, dec);
        });
    }
    reset() {
        this.gauge.reset();
    }
    timer(key) {
        return this.gauge.startTimer({
            key: 0
        });
    }
}
//# sourceMappingURL=metric-group.js.map