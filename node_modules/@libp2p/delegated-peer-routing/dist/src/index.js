import { logger } from '@libp2p/logger';
import { CID } from 'multiformats/cid';
import PQueue from 'p-queue';
import defer from 'p-defer';
import errCode from 'err-code';
import anySignal from 'any-signal';
import { peerIdFromBytes } from '@libp2p/peer-id';
const log = logger('libp2p-delegated-peer-routing');
const DEFAULT_TIMEOUT = 30e3; // 30 second default
const CONCURRENT_HTTP_REQUESTS = 4;
export var EventTypes;
(function (EventTypes) {
    EventTypes[EventTypes["SENDING_QUERY"] = 0] = "SENDING_QUERY";
    EventTypes[EventTypes["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
    EventTypes[EventTypes["FINAL_PEER"] = 2] = "FINAL_PEER";
    EventTypes[EventTypes["QUERY_ERROR"] = 3] = "QUERY_ERROR";
    EventTypes[EventTypes["PROVIDER"] = 4] = "PROVIDER";
    EventTypes[EventTypes["VALUE"] = 5] = "VALUE";
    EventTypes[EventTypes["ADDING_PEER"] = 6] = "ADDING_PEER";
    EventTypes[EventTypes["DIALING_PEER"] = 7] = "DIALING_PEER";
})(EventTypes || (EventTypes = {}));
/**
 * The types of messages set/received during DHT queries
 */
export var MessageType;
(function (MessageType) {
    MessageType[MessageType["PUT_VALUE"] = 0] = "PUT_VALUE";
    MessageType[MessageType["GET_VALUE"] = 1] = "GET_VALUE";
    MessageType[MessageType["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    MessageType[MessageType["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    MessageType[MessageType["FIND_NODE"] = 4] = "FIND_NODE";
    MessageType[MessageType["PING"] = 5] = "PING";
})(MessageType || (MessageType = {}));
class DelegatedPeerRouting {
    /**
     * Create a new DelegatedPeerRouting instance
     */
    constructor(client) {
        if (client == null) {
            throw new Error('missing ipfs http client');
        }
        this.client = client;
        this.started = false;
        this.abortController = new AbortController();
        // limit concurrency to avoid request flood in web browser
        // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12
        this.httpQueue = new PQueue({
            concurrency: CONCURRENT_HTTP_REQUESTS
        });
        const { protocol, host, port } = client.getEndpointConfig();
        log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);
    }
    isStarted() {
        return this.started;
    }
    start() {
        this.started = true;
    }
    stop() {
        this.httpQueue.clear();
        this.abortController.abort();
        this.abortController = new AbortController();
        this.started = false;
    }
    /**
     * Attempts to find the given peer
     */
    async findPeer(id, options = {}) {
        log('findPeer starts: %p', id);
        options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
        options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []));
        const onStart = defer();
        const onFinish = defer();
        void this.httpQueue.add(async () => {
            onStart.resolve();
            return await onFinish.promise;
        });
        try {
            await onStart.promise;
            for await (const event of this.client.dht.findPeer(id, options)) {
                if (event.name === 'FINAL_PEER') {
                    const peerInfo = {
                        id: event.peer.id,
                        multiaddrs: event.peer.multiaddrs,
                        protocols: []
                    };
                    return peerInfo;
                }
            }
        }
        catch (err) {
            log.error('findPeer errored: %o', err);
            throw err;
        }
        finally {
            onFinish.resolve();
            log('findPeer finished: %p', id);
        }
        throw errCode(new Error('Not found'), 'ERR_NOT_FOUND');
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options = {}) {
        let cidOrPeerId;
        const cid = CID.asCID(key);
        if (cid != null) {
            cidOrPeerId = cid;
        }
        else {
            cidOrPeerId = peerIdFromBytes(key);
        }
        log('getClosestPeers starts: %s', cidOrPeerId);
        options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
        options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []));
        const onStart = defer();
        const onFinish = defer();
        void this.httpQueue.add(async () => {
            onStart.resolve();
            return await onFinish.promise;
        });
        try {
            await onStart.promise;
            for await (const event of this.client.dht.query(cidOrPeerId, options)) {
                if (event.name === 'PEER_RESPONSE') {
                    yield* event.closer.map(closer => ({
                        id: closer.id,
                        multiaddrs: closer.multiaddrs,
                        protocols: []
                    }));
                }
            }
        }
        catch (err) {
            log.error('getClosestPeers errored:', err);
            throw err;
        }
        finally {
            onFinish.resolve();
            log('getClosestPeers finished: %b', key);
        }
    }
}
export function delegatedPeerRouting(client) {
    return () => new DelegatedPeerRouting(client);
}
//# sourceMappingURL=index.js.map