export class IpnsResolver {
    /**
     * @param {import('ipfs-core-types/src/utils').BufferStore} routing
     */
    constructor(routing: import('ipfs-core-types/src/utils').BufferStore);
    _routing: import("ipfs-core-types/src/utils").BufferStore;
    /**
     * @param {string} name
     * @param {object} [options]
     * @param {boolean} [options.recursive]
     * @param {AbortSignal} [options.signal]
     */
    resolve(name: string, options?: {
        recursive?: boolean | undefined;
        signal?: AbortSignal | undefined;
    } | undefined): Promise<string>;
    /**
     * Recursive resolver according to the specified depth
     *
     * @param {string} name
     * @param {number} depth
     * @param {AbortOptions} options
     * @returns {Promise<string>}
     */
    resolver(name: string, depth: number, options: AbortOptions): Promise<string>;
    /**
     * Resolve ipns entries from the provided routing
     *
     * @param {string} name
     * @param {AbortOptions} options
     */
    _resolveName(name: string, options: AbortOptions): Promise<string>;
    /**
     * Validate a resolved record
     *
     * @param {PeerId} peerId
     * @param {Uint8Array} record
     */
    _validateRecord(peerId: PeerId, record: Uint8Array): Promise<string>;
}
export type PeerId = import('@libp2p/interface-peer-id').PeerId;
export type AbortOptions = import('@libp2p/interfaces').AbortOptions;
//# sourceMappingURL=resolver.d.ts.map