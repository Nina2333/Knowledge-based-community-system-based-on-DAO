(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PTrackedMap = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PTrackedMap=(()=>{var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var o=Object.getOwnPropertyNames;var u=Object.prototype.hasOwnProperty;var a=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},m=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of o(e))!u.call(r,n)&&n!==t&&i(r,n,{get:()=>e[n],enumerable:!(s=p(e,n))||s.enumerable});return r};var d=r=>m(i({},"__esModule",{value:!0}),r);var h={};a(h,{trackedMap:()=>l});var c=class extends Map{constructor(e){super();let{name:t,metrics:s}=e;this.metric=s.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){let t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}};function l(r){let{name:e,metrics:t}=r,s;return t!=null?s=new c({name:e,metrics:t}):s=new Map,s}return d(h);})();
return Libp2PTrackedMap}));
