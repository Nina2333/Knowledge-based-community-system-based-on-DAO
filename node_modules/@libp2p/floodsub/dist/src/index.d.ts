import { PubSubBaseProtocol, PubSubComponents } from '@libp2p/pubsub';
import { multicodec } from './config.js';
import { SimpleTimeCache } from './cache.js';
import type { PubSubInit, Message, PubSubRPC, PubSubRPCMessage, PublishResult, PubSub } from '@libp2p/interface-pubsub';
import type { PeerId } from '@libp2p/interface-peer-id';
import type { Uint8ArrayList } from 'uint8arraylist';
export { multicodec };
export interface FloodSubInit extends PubSubInit {
    seenTTL?: number;
}
export interface FloodSubComponents extends PubSubComponents {
}
/**
 * FloodSub (aka dumbsub is an implementation of pubsub focused on
 * delivering an API for Publish/Subscribe, but with no CastTree Forming
 * (it just floods the network).
 */
export declare class FloodSub extends PubSubBaseProtocol {
    seenCache: SimpleTimeCache<boolean>;
    constructor(components: FloodSubComponents, init?: FloodSubInit);
    /**
     * Decode a Uint8Array into an RPC object
     */
    decodeRpc(bytes: Uint8Array | Uint8ArrayList): PubSubRPC;
    /**
     * Encode an RPC object into a Uint8Array
     */
    encodeRpc(rpc: PubSubRPC): Uint8Array;
    decodeMessage(bytes: Uint8Array | Uint8ArrayList): PubSubRPCMessage;
    encodeMessage(rpc: PubSubRPCMessage): Uint8Array;
    /**
     * Process incoming message
     * Extends base implementation to check router cache.
     */
    processMessage(from: PeerId, message: Message): Promise<void>;
    /**
     * Publish message created. Forward it to the peers.
     */
    publishMessage(from: PeerId, message: Message): Promise<PublishResult>;
}
export declare function floodsub(init?: FloodSubInit): (components: FloodSubComponents) => PubSub;
//# sourceMappingURL=index.d.ts.map