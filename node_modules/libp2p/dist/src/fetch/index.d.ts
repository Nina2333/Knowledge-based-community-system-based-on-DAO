import type { PeerId } from '@libp2p/interface-peer-id';
import type { Startable } from '@libp2p/interfaces/startable';
import type { Stream } from '@libp2p/interface-connection';
import type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar';
import type { AbortOptions } from '@libp2p/interfaces';
import type { ConnectionManager } from '@libp2p/interface-connection-manager';
export interface FetchServiceInit {
    protocolPrefix: string;
    maxInboundStreams: number;
    maxOutboundStreams: number;
    /**
     * How long we should wait for a remote peer to send any data
     */
    timeout: number;
}
export interface HandleMessageOptions {
    stream: Stream;
    protocol: string;
}
export interface LookupFunction {
    (key: string): Promise<Uint8Array | null>;
}
export interface FetchServiceComponents {
    registrar: Registrar;
    connectionManager: ConnectionManager;
}
/**
 * A simple libp2p protocol for requesting a value corresponding to a key from a peer.
 * Developers can register one or more lookup function for retrieving the value corresponding to
 * a given key.  Each lookup function must act on a distinct part of the overall key space, defined
 * by a fixed prefix that all keys that should be routed to that lookup function will start with.
 */
export declare class FetchService implements Startable {
    readonly protocol: string;
    private readonly components;
    private readonly lookupFunctions;
    private started;
    private readonly init;
    constructor(components: FetchServiceComponents, init: FetchServiceInit);
    start(): Promise<void>;
    stop(): Promise<void>;
    isStarted(): boolean;
    /**
     * Sends a request to fetch the value associated with the given key from the given peer
     */
    fetch(peer: PeerId, key: string, options?: AbortOptions): Promise<Uint8Array | null>;
    /**
     * Invoked when a fetch request is received.  Reads the request message off the given stream and
     * responds based on looking up the key in the request via the lookup callback that corresponds
     * to the key's prefix.
     */
    handleMessage(data: IncomingStreamData): Promise<void>;
    /**
     * Given a key, finds the appropriate function for looking up its corresponding value, based on
     * the key's prefix.
     */
    _getLookupFunction(key: string): LookupFunction | undefined;
    /**
     * Registers a new lookup callback that can map keys to values, for a given set of keys that
     * share the same prefix
     *
     * @example
     *
     * ```js
     * // ...
     * libp2p.fetchService.registerLookupFunction('/prefix', (key) => { ... })
     * ```
     */
    registerLookupFunction(prefix: string, lookup: LookupFunction): void;
    /**
     * Registers a new lookup callback that can map keys to values, for a given set of keys that
     * share the same prefix.
     *
     * @example
     *
     * ```js
     * // ...
     * libp2p.fetchService.unregisterLookupFunction('/prefix')
     * ```
     */
    unregisterLookupFunction(prefix: string, lookup?: LookupFunction): void;
}
//# sourceMappingURL=index.d.ts.map