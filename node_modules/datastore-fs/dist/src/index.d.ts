/**
 * A datastore backed by the file system.
 *
 * Keys need to be sanitized before use, as they are written
 * to the file system as is.
 *
 * @implements {Datastore}
 */
export class FsDatastore extends BaseDatastore implements Datastore {
    /**
     * @param {string} location
     * @param {{ createIfMissing?: boolean, errorIfExists?: boolean, extension?: string, putManyConcurrency?: number } | undefined} [opts]
     */
    constructor(location: string, opts?: {
        createIfMissing?: boolean;
        errorIfExists?: boolean;
        extension?: string;
        putManyConcurrency?: number;
    } | undefined);
    path: string;
    opts: {
        createIfMissing: boolean;
        errorIfExists: boolean;
        extension: string;
        deleteManyConcurrency: number;
        getManyConcurrency: number;
        putManyConcurrency: number;
    } & {
        createIfMissing?: boolean | undefined;
        errorIfExists?: boolean | undefined;
        extension?: string | undefined;
        putManyConcurrency?: number | undefined;
    };
    /**
     * Calculate the directory and file name for a given key.
     *
     * @private
     * @param {Key} key
     * @returns {{dir:string, file:string}}
     */
    private _encode;
    /**
     * Calculate the original key, given the file name.
     *
     * @private
     * @param {string} file
     * @returns {Key}
     */
    private _decode;
    /**
     * Write to the file system without extension.
     *
     * @param {Key} key
     * @param {Uint8Array} val
     * @returns {Promise<void>}
     */
    putRaw(key: Key, val: Uint8Array): Promise<void>;
    /**
     * Store the given value under the key
     *
     * @param {Key} key
     * @param {Uint8Array} val
     * @returns {Promise<void>}
     */
    put(key: Key, val: Uint8Array): Promise<void>;
    /**
     * @param {AwaitIterable<Pair>} source
     * @returns {AsyncIterable<Pair>}
     */
    putMany(source: AwaitIterable<Pair>): AsyncIterable<Pair>;
    /**
     * Read from the file system without extension.
     *
     * @param {Key} key
     * @returns {Promise<Uint8Array>}
     */
    getRaw(key: Key): Promise<Uint8Array>;
    /**
     * Read from the file system.
     *
     * @param {Key} key
     * @returns {Promise<Uint8Array>}
     */
    get(key: Key): Promise<Uint8Array>;
    /**
     * @param {AwaitIterable<Key>} source
     * @returns {AsyncIterable<Uint8Array>}
     */
    getMany(source: AwaitIterable<Key>): AsyncIterable<Uint8Array>;
    /**
     * @param {AwaitIterable<Key>} source
     * @returns {AsyncIterable<Key>}
     */
    deleteMany(source: AwaitIterable<Key>): AsyncIterable<Key>;
    /**
     * Check for the existence of the given key.
     *
     * @param {Key} key
     * @returns {Promise<boolean>}
     */
    has(key: Key): Promise<boolean>;
    /**
     * Delete the record under the given key.
     *
     * @param {Key} key
     * @returns {Promise<void>}
     */
    delete(key: Key): Promise<void>;
    /**
     * @param {Query} q
     */
    _all(q: Query): AsyncGenerator<import("interface-datastore").Pair, void, unknown>;
    /**
     * @param {KeyQuery} q
     */
    _allKeys(q: KeyQuery): AsyncGenerator<Key, void, undefined>;
}
export type Datastore = import('interface-datastore').Datastore;
export type Pair = import('interface-datastore').Pair;
export type Query = import('interface-datastore').Query;
export type KeyQuery = import('interface-datastore').KeyQuery;
export type AwaitIterable<TEntry> = import('interface-store').AwaitIterable<TEntry>;
import { BaseDatastore } from "datastore-core";
import { Key } from "interface-datastore";
//# sourceMappingURL=index.d.ts.map