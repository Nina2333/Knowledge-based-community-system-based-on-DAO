import type { Multiaddr } from '@multiformats/multiaddr';
import { symbol, Upgrader } from '@libp2p/interface-transport';
import type { AbortOptions } from '@libp2p/interfaces';
import type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar';
import type { Listener, Transport, CreateListenerOptions } from '@libp2p/interface-transport';
import type { Connection } from '@libp2p/interface-connection';
import type { RelayConfig } from './index.js';
import type { Startable } from '@libp2p/interfaces/startable';
import type { ConnectionManager } from '@libp2p/interface-connection-manager';
import type { PeerId } from '@libp2p/interface-peer-id';
import type { PeerStore } from '@libp2p/interface-peer-store';
import type { AddressManager } from '@libp2p/interface-address-manager';
export interface CircuitComponents {
    peerId: PeerId;
    peerStore: PeerStore;
    registrar: Registrar;
    connectionManager: ConnectionManager;
    upgrader: Upgrader;
    addressManager: AddressManager;
}
export declare class Circuit implements Transport, Startable {
    private handler?;
    private readonly components;
    private readonly _init;
    private _started;
    constructor(components: CircuitComponents, init: RelayConfig);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    hopEnabled(): boolean;
    hopActive(): boolean;
    get [symbol](): true;
    get [Symbol.toStringTag](): string;
    _onProtocol(data: IncomingStreamData): Promise<void>;
    /**
     * Dial a peer over a relay
     */
    dial(ma: Multiaddr, options?: AbortOptions): Promise<Connection>;
    /**
     * Create a listener
     */
    createListener(options: CreateListenerOptions): Listener;
    /**
     * Filter check for all Multiaddrs that this transport can dial on
     *
     * @param {Multiaddr[]} multiaddrs
     * @returns {Multiaddr[]}
     */
    filter(multiaddrs: Multiaddr[]): Multiaddr[];
}
//# sourceMappingURL=transport.d.ts.map